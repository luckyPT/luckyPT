推荐系统知识梳理
====
参考：<br>
![极客时间邀请帖](/docs/ml/images/23-1.jpg)

## 推荐系统（Recommender System）在做什么
维基百科定义：是信息过滤系统中的一种，主要手段是预测用户对物品的偏好；

本质上是在让人与物品之间建立连接关系，比如：文章推荐、音乐推荐、商品推荐、视频推荐、APP推荐、好友推荐等，都是为了让人消费这个物品，与这个物品建立起连接。

同时，由于马太效应(长尾效应)的存在，导致部分热门物品占用了大量连接，尾部的物品则连接数极少，推荐系统在一定程度上来讲也是为了对抗这种不平衡。

- 能做什么？寻找到用户和物品之间可能建立的连接
- 需要什么？需要已存在的连接，通过现有连接预测未来连接发生的可能性
- 怎么做？机器推荐(个性化推荐) 和 人工推荐（编辑推荐）

## 什么场景下需要推荐系统
第一，产品的目的是为了建立更多的连接；

比如资讯类APP、电商类APP，就是为了让用户阅读更多的文章、购买更多的商品；<br>
但是一些工具类APP，比如：日历、闹钟等一般来将不会有太多的连接需求，但这个也不是绝对的，这些APP为了提高日活和使用时长，往往也会增加一些功能，比如：日历的节日相关文章推送、闹钟的工作日提醒等，那么这些推送和提醒可能也是希望用户和这些通知建立起连接关系，会涉及到文案、时间、通知样式的选择等

第二，满足第一点的前提下，说明已经存在连接；后期连接数的增长如果主要依赖用户或者是物品的增长而增长，那么这个时候对于推荐系统的需求就不是太大，而如果连接增长主要是基于现有用户和物品而增长的，那么就比较需要一个推荐系统

## 两类常见场景以及模型
预测用户打分的场景：一般对应回归模型，就是预测用户会对产品给出的打分，如：1~10分 或者 1~5颗星等<br>
预测用户行为场景：一般对应于分类模型，比如经典的CTR预估；另外一个场景是预测物品的相对排序；

对应于评分场景来说，数据获取难度比较大，数据也比较稀疏（很多人消费之后是不会评分的）；而对于行为预测来说，数据往往相对稠密一些（比如浏览时长、加购物车、收藏等）；

另外对应于评分数据属于显示反馈，往往存在一定的主观性，比如有的人就比较喜欢打高分，有的人则比较偏重于低分；而隐式反馈有时候往往更能体现用户的真实意图，比如：有的人很讨厌某个人，但还是经常浏览他的相关新闻并且时不时差评一下；

## 算法
### ▶基于内容的推荐
基于内容的推荐系统某种意义上来讲可以看做是检索系统或者是搜索系统，这种系统的搭建相对简单、快速，而且往往也会有一个显著的效果；这类推荐系统可以看作是推荐系统的雏形；

**什么是基于内容的推荐**<br>
“基于内容” 这里的内容包含两部分，一部分是商品的内容（商品的属性、标签、各个维度的特征等），另一部分是用户的内容（用户画像等）；<br>
基于这两部分内容去计算相似度；比如：简单的CTR预估，就是根据用户属性+商品属性构造特征，计算点击率；

**基于内容推荐有什么好处**<br>
1. 无论是算法方面还是工程方面，实现起来相对简单；(不用计算用户相似度、商品相似度、协同矩阵等)<br>
2. 数据比较易得，用户内容和商品内容的获得相对比较容易；（协同过滤则需要用户跟商品的链接，一般来讲需要长时间积累）

**基于内容推荐和协同过滤的区别**<br>
前者只使用用户内容和商品内容，不会用到商品和用户之间的链接；也不会直接利用相似用户和相似商品去做推荐；<br>
后者更强调用户与产品之间的连接信息，同时会考虑使用相似用户或者相似产品的行为、表现数据去做预测；

### ▶近邻推荐（协同过滤）
**基于用户的协同过滤**<br>
利用相似用户消费过的商品来给目标用户推荐商品；结果是得到：相似用户列表 和 推荐结果<br>
1.构造用户向量（向量维度就是商品的个数）<br>
2.针对用户计算两两之间的相似度<br>
3.针对某一商品和目标用户，首先筛选出相似用户，然后根据相似用户对商品的评价以及相似度进行加权求和，得到预测的评价；<br>
分子式 用户相似度和评价的积，进行求和；分母是所有用户相似度之和。可以理解为把相似度看成了评价的权值，相似度越高，对应评价的权值越大。

改进：
- 计算相似度时，对于热门物品的评价或者行为做一定的降权，因为热门物品可能并不是用户的真实兴趣，往往受煽动或者外界某些因素影响更大；
- 增加喜欢程度的时间衰减，时间越近的行为/评价计算得到的相似性权重应该越大；

一些缺点：
- 用户量大，耗费的算力大；（一般来讲 用户量远大于产品数量）
- 用户口味变化快，用户相似度不是静态的
- 数据稀疏性

**基于物品的协同过滤**<br>
利用目标用户消费过的商品来推荐相似商品；结果得到：相似物品列表 和 推荐结果

1. 构造用户、物品关系矩阵；行表示物品向量，每一个用户是一个维度；<br>
2. 计算物品向量的相似度<br>
3. 产生推荐结果；找到某个用户消费的一系列商品，找到一个待推荐商品按照与这些产品的相似度加权计算评分；最终得到这个用户对这个商品的预测评分<br>

相似度计算的改进：
- 物品中性化&用户中性化；也就是每一个元素减去所在行的均值和所在列的均值，防止有的用户就爱打高分或打低分，有的物品对应的粉丝就爱打高分或者打低分；

SLOPE ONE 算法：<br>
该算法只适用于评分场景，并且是基于物品的协同过滤；核心思想在于事先计算好物品之间的平均差异；<br>
比如：用户1 对物品a评分为1，对物品b评分1.5；用户2对物品a评分为2，那么推断用户2对物品b评分为2.5，理由：根据用户A的评价，得出产品b比产品a高0.5分，这就是产品a和b的差异，因为已经知道用户2对a的评分是2，所以根据差异推测用户2对产品b的评分是2.5；<br>
上面只是一个非常简单的例子，实际上计算两个物品的差异需要用到多个用户的评分，求平均差异，并且将用户数作为置信度；<br>
对于新的用户和产品的连接，也不仅仅是参考一对产品差异，而是多组产品差异根据置信度加权求解；

SLONE ONE算法优点：
- 算法简单，可以做到在线更新
- 引入了置信度，一定程度上解决了某些badcase，比如：物品A 和 B均被同一个用户消费了，并且只被同一个用户消费了，这个时候按照其他计算方式物品A和B的相似度会很高；但在slope one里面可以借助置信度来缓解这个问题；


**协同过滤的应用场景**
- 推荐商品（可以离线完成计算，用户登陆之后在首页推荐）
- 利用基于用户的协同过滤产生的用户相似列表构建社交群、粉丝群之类的；或者推荐相似好友等
- 利用基于物品的协同过滤产生的物品相似列表，在用户消费完一个产品之后，推荐与这个产品相似的产品

#### 相似度计算方法
[参考:降维技术与特征选择](/docs/ml/16_1.md)

### ▶ 矩阵分解
[参考:奇异值分解](/docs/ml/25.md)

**矩阵分解如何应用于行为预测**<br>
链接中提到的矩阵分解一般应用于评分系统中，如果是行为预测，则需要做一些调整；<br>
主要区别是：在评分场景下，我们只拟合有评分的数据（拟合没有评分的数据没有意义），但是在行为预测场景下，除了需要拟合有行为的数据之外，还需要拟合没有行为的数据；（一般都是这么做的，具体还没太想明白）,这也就是One-class问题：<br>

在预测用户行为时，我们拿到的数据往往是这样的，如果行为发生那么这种结果是确定的，如果行为不发生 那么结果是不确定的，也许真的不发生 也许只是用户没有机会发生这种行为（比如：产品没有曝光到用户面前）；

正负样本数据不均衡、负样本并不是真的负样本，这个时候负样本应该如何选取？（我们的目的是希望选取到那些真的负样本，比如用户看到但是没点击的样本要比用户没看到并且没点击的样本好）<br>
解决方案之一，按照物品的热门程度选取一般来说效果更好，因为物品热门程度越高，用户接触到的概率越大，这时候负样本的准确度也越高；

关于损失函数，对于用户和产品之间的连接行为是可以作为样本权重参考的，比如：用户浏览1次 和用户浏览3次，同样是浏览行为 但可以根据浏览次数在损失函数上加以权值，浏览次数多的如果判断错误应该受到更大的惩罚；

**相关工具**<br>
Faiss、Annoy、KGraph、NMSLIB

### ▶ 推荐系统中的排序算法（BPR 贝叶斯个性化排序）
BPR算法目标也是求解用户和物品的隐向量，但跟上面讲到的矩阵分解不同的是，矩阵分解的目标是求解最合适的参数使得用户和物品的连接值符合预期，俗称(point wise);而BPR目标是求解最合适的参数，使得用户对物品的喜好程度与打分成正比；具体流程如下：<br>
1. 构造训练数据，矩阵分解的训练数据样本一般为（用户、物品、标签）；而BPR训练数据为（用户，物品i，物品j，标签）这里的物品i和物品j有且只有一个被用户消费过，如果i被消费过，则视为正样本，如果j被消费过，则视为负样本；<br>
2. 预测函数的形式，依然用用户和物品做点积计算得分，对i的得分和对j的得分做差，然后使用sigmoid进行激活，得到预测值；
3. 损失函数的形式，与逻辑回归类似，选择交叉熵作为损失函数

最终模型的评价指标一般使用AUC，AUC的含义就是当一个正样本和负样本出现的时候，正样本评分大于负样本的概率；
[参考:Recommender system using Bayesian personalized ranking](https://towardsdatascience.com/recommender-system-using-bayesian-personalized-ranking-d30e98bba0b9)


### 推荐系统中常见的问题
- 冷启动问题<br>
1. 冷启动场景下的推荐看作是MBA问题，采样bandit算法思想解决，常用的方法有：汤普森采样算法、UCB采样、LinUCB算法<br>
2. 构建排行榜体系，按照排行榜进行推荐

- 探索与利用问题<br>
1. 利用Bandit算法种的策略<br>
2. 预测时随机丢掉用户的某些兴趣标签或者历史行为等

- 安全问题

- 用户向量太长，引起的存储太大和相似度计算耗时太大怎么办<br>
存储问题：使用稀疏矩阵存储解决<br>
相似度计算耗时：对向量进行采样降维，计算降维之后的相似度；将相似度计算转化为向量计算（尽量不要自己使用循环计算），这种计算方式非常快；

- 用户太多，两两计算相似度成本太大<br>
利用map-reduce思想，并行计算；<br>
或者可以先通过简易方式筛选出需要计算相似度的用户(甚至可以随机选取一部分用户)，降低需要计算的用户量之后，再进行计算；不计算相似度的，相似度都按照0来计算；（个人想法）<br>


### 认识用户
通俗一点来说就是用户画像（user profile）；<br>
这里所说的认识用户或者用户画像本质上是面向机器的，当然人类可读的话是最好的，但实际上人类可不可读并不是非常重要；其表现形式是一个或者是多个向量<br>
用户画像一般包含两个要素：维度以及维度的量化<br>
维度的名称可理解、维度的数量以及有哪些维度是不确定的，需要持续探索挖掘；<br>
维度的量化应该交给机器、以目标为导向；以推荐效果来反向优化用户画像才有意义；（**目标思维**）

用户画像的构建：<br>
1. 直接使用原始数据<br>
比如：用户注册时的年龄、性别、地域；用户使用的设备型号、打开APP的时间段以及APP使用情况(如：阅读历史、购买历史等)<br>
2. 数据统计分析<br>
堆积了一定量的数据之后，进行统计分析，比如统计用户的兴趣标签(如果用户只读了一篇文章，那么统计兴趣标签意义不大，或者说兴趣标签就是这个文章的标签)、用户对每类标签的点击率、阅读的完成度等等；<br>
3. 黑盒<br>
用机器学习的方法，构建人类不可读的稠密向量；比如将设备型号、地域等表达为稠密向量；

用户画像数据的分类:<br>
基础类（原始数据）、行为类（统计分析得到）、衍生类（统计分析得到）、模型类（黑盒数据、算法训练得到）；

### 基于文本构建用户画像
文本数据往往是非结构化的，需要将非结构化数据转为结构化数据；<br>
1、关键词提取(如：TF-IDF & TEXT RANK)<br>
2、实体识别<br>
3、文本分类<br>
4、文本聚类<br>
5、预测文本的主题模型(文本在各个主题上的概率分布)<br>
6、embedding<br>

### 特征选择
1.卡方检验

2.信息增益

