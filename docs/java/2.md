集合类
====
两个终极接口Collection和Map；<br>
Collection下面主要是List、Set、Queue
## List
继承关系如下：<br>
![List继承关系](/docs/java/images/2-1.jpg)

ListIterator相比iterator增加了：add、set、nextIndex、previousIndex以及前向访问相关方法。

**ArrayList：** 使用数组存储```transient Object[] elementData;```，当List为空时，默认共享同一个静态变量。当第一个元素加入到List时，数组默认大小是10，当插入元素时如果发现空间不够，首先扩展为原来的三倍，如果还是不够，则需要多少就创建多大的数组。最大是Interger.MAX_VALUE;由于扩容造成的内存浪费，可以使用trimToSize方法解决<br>
ArrayList并非是线程安全的。

**Vector:**  使用数组存储，与ArrayList的主要区别在于 很多方法是同步实现的。

**Stack：** 基于Vevtor实现栈结构。很多方法也是线程安全的。提供了search方法，可以返回被搜索元素到栈顶的距离。

**LinkedList:** 元素以Node的方式存储，只记录头结点和尾结点，其余结点通过Node之间的指针关联。Node定义如下：
```JAVA
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```
LinkedList实现了双向队列接口

## Map
继承关系如下：<br>
![Map继承关系](/docs/java/images/2-2.jpg)<br>
**HashMap：**采用数组+链表+红黑树实现。首先是以数组的形式存储Node，数组的扩容根据负载因子（数组的使用率），默认当使用率超过0.75就扩容为原来的2倍。
```JAVA
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
transient Node<K,V>[] table;  
```
当插入元素的时候，先根据key找到该元素在数组中应该对应的位置，如果该位置为null，则直接将新的Node放到该位置。否则判断该位置是TreeNode还是链表Node，如果是TreeNode，则加入到红黑树中，如果是链表Node，则放到链表最后。加入到链表最后时，检查是否超过“链表转树的阈值”，如果超过则转为红黑树。数组的该位置应该是红黑树的根。
```JAVA
if ((p = tab[i = (n - 1) & hash]) == null) //hash 是根据key得来的
    tab[i] = newNode(hash, key, value, null);
...
else if (p instanceof TreeNode)
    e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
...
```

## Set
继承关系如下：<br>

## Queue
继承关系如下：<br>
