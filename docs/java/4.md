多线程
====
1. 线程的生命周期

2. 可见性、原子性、有序性问题（并发编程bug的源头）

3. volatile关键字

4. threadLocal变量

5. Semaphore

6. CorrentHashMap的实现（JDK7 与 8有区别）

7. Thread 类源码分析

**wait()**<br>
使当前线程等待，直到其他线程调用该对象的notify()或者notifyAll()方法；，该方法是native实现的<br>
调用该方法的线程，必须拥有该对象的锁；否则会抛异常。调用此方法之后，当前线程会让出该对象的锁。<br>
变种：可以指定等待时间。

**notify()/notifyAll()**<br>
唤醒其他线程，与wait一样，调用该方法的线程，必须拥有该对象的锁；否则会抛异常。<br>
被唤醒的线程不会立即执行，需要等待当前线程放弃持有的锁。<br>
前者随机唤醒一个等待线程（即调用该对象wait方法的线程）；后者是唤醒所有线程。

**registerNatives()**<br>
可以简单理解为让JVM找到本地函数，同时可以按照JAVA的风格进行命名；

**private volatile String name**<br>
线程名，用户可以自己设置：public final synchronized void setName(String name) {...

**构造函数**<br>
终极构造函数：public Thread(ThreadGroup group, Runnable target, String name,long stackSize) {...

target - 线程需要执行的任务<br>
name - 线程名<br>
stackSize - 线程栈的大小，JVM会按照这个参数分配近似的内存空间。<br>
group - 一组线程的集合，方便线程的统一管理；比如可以查看一共有多少个active状态的线程（返回的是一个估计值），同时interuppt所有线程等。

**private static synchronized int nextThreadNum()**<br>
从0开始，每次加1；默认情况下不指定线程名会就会以："Thread-" + nextThreadNum() 命名，指定线程名后则不会再调用这个方法；

**private static synchronized long nextThreadID()**<br>
生成threadId，最终赋值为 private long tid;这个属性。

**public static native Thread currentThread();**<br>
静态方法，获取当前线程

**public static native void yield();**<br>
静态方法，通知线程调度器，当前线程可以让出自己正在使用的CPU；不过调度器也许会忽略这一个通知。<br>
一般可以用于启发式尝试管理多线程之间的进度，让CPU超负载的线程可以多分得一些CPU；或者是在多线程测试，复现bug阶段可以尝试使用。实际上用的比较少。

**public static native void sleep(long millis)**<br>
程序暂停执行，但并不放弃锁

**public synchronized void start() {**<br>
启动一个线程，使得线程由新建状态转为就绪状态。

**private void exit() {**<br>
系统会自动调用这个方法，以便做一些资源清理工作。

**stop()/stop(Throwable obj) {**<br>
已经废弃的方法，不推荐使用；作用是强制停止线程运行，后者在JDK8里面已经不在使用，调用时直接会抛异常。<br>
废弃原因：因为stop方法不会释放锁，所以存在安全隐患。

**public void interrupt() {**<br>
这里涉及到中断机制，如果当前线程正在因为wait/join/sleep方法阻塞，那么会抛出InterruptedException异常，中断状态将被重置，（即终端状态为false）；<br>
如果因为IO阻塞，那么会抛出：ClosedByInterruptException异常，并且设置中断状态的True；<br>
如果因为nio的Selector机制被阻塞，那么会设置中断状态，并且selection operation会立即返回；

然后设置了interrupt状态之后，需要线程自己主动检测，才能处理；并不一定会导致线程终止。

**public static boolean interrupted()**<br>
静态方法，检测当前线程是否被interrupted

**public boolean isInterrupted()/private native boolean isInterrupted(boolean ClearInterrupted)**<br>
判断某个线程是否interrupted，并且可以设置是否重置interrupted的状态。

**destroy()**<br>
JDK1.8已经废弃；该方法会直接销毁线程，而不做任何资源/锁的释放工作

**public final native boolean isAlive()**<br>
判断线程是否存活，一个线程启动之后，在死亡之前的状态，都是存活状态；

**suspend()/resume()**<br>
暂停线程/恢复暂停的线程；由于线程在暂停的时候，并不会释放锁，因此存在较大的死锁隐患，所以已经废弃；

**public final void setPriority(int newPriority) { / getPriority()**<br>
设置线程权重，1 ~ 10；会受所在group最高权重的限制。

**setName/getName**<br>
设置或获取线程的名字

**public final ThreadGroup getThreadGroup()**<br>
获取线程所在的组

**public static int activeCount()**<br>
获取当前线程组中存活线程的数量

**public static int enumerate(Thread tarray[])**<br>
将当前线程所在的线程组中存活的线程拷贝到tarray中。可以通过activeCount来粗略确定tarray的大小，如果数组太小，那么多余的线程将被忽略，不会抛异常。返回值是完成拷贝线程的数量。

**public native int countStackFrames();**<br>
已废弃，统计当前线程的所用栈帧。因为必须挂起当前线程（调用suspend方法），所以已经废弃。

**public final synchronized void join(long millis)/join()/**<br>
本质上借助wait方法，使用循环实现对当前线程阻塞，直到调用的线程对象死亡。

**public static void dumpStack()**<br>
打印当前线程堆栈

**public final void setDaemon(boolean on)/isDaemon()** <br>
设定当前线程为守护线程，需要在start之前设定;后者判断当前线程是否为守护线程；<br>
对于虚拟机来说，如果运行的所有线程都是守护线程，那么虚拟机将会自动退出。

**public final void checkAccess()**<br>
检测当前运行的线程是否有权力修改this线程对象。如果当前线程不能访问this线程对象，则会抛出异常。

**toString()**<br>
默认会输出线程名，权重；如果group不等于null，也会输出group的名字。

**public static native boolean holdsLock(Object obj);**<br>
判断当前线程是否持有锁对象

**public StackTraceElement[] getStackTrace()**<br>
获取Thread对象的线程栈。

**public static Map<Thread, StackTraceElement[]> getAllStackTraces()**<br>
获取所有线程的线程栈

**public State getState()**<br>
获取线程状态：NEW/RUNNABLE(就绪状态，但未必在运行)/BLOCKED（等待锁）/WAITING（调用wait()、join()、park()之后的状态）/TIMED_WAITING（调用wait(long)、join(long)、parkUntil、parkNanos之后）/TERMINATED 已经完成执行

**public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {/getDefaultUncaughtExceptionHandler**<br>
静态方法，设置线程异常时默认的处理方式；

**public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)/getUncaughtExceptionHandler()**<br>
设置线程异常的处理方式；









