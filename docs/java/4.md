多线程
====
1. 线程的生命周期

2. 可见性、原子性、有序性问题（并发编程bug的源头）

3. volatile关键字

4. threadLocal变量

5. Semaphore

6. CorrentHashMap的实现（JDK7 与 8有区别）

7.Thread 类源码分析

**wait()**<br>
使当前线程等待，直到其他线程调用该对象的notify()或者notifyAll()方法；，该方法是native实现的<br>
调用该方法的线程，必须拥有该对象的锁；否则会抛异常。调用此方法之后，当前线程会让出该对象的锁。<br>
变种：可以指定等待时间。

**notify()/notifyAll()**<br>
唤醒其他线程，与wait一样，调用该方法的线程，必须拥有该对象的锁；否则会抛异常。<br>
被唤醒的线程不会立即执行，需要等待当前线程放弃持有的锁。<br>
前者随机唤醒一个等待线程（即调用该对象wait方法的线程）；后者是唤醒所有线程。

**registerNatives()**<br>
可以简单理解为让JVM找到本地函数，同时可以按照JAVA的风格进行命名；

**private volatile String name**<br>
线程名，用户可以自己设置：public final synchronized void setName(String name) {...

**构造函数**<br>
终极构造函数：public Thread(ThreadGroup group, Runnable target, String name,long stackSize) {...

target - 线程需要执行的任务<br>
name - 线程名<br>
stackSize - 线程栈的大小，JVM会按照这个参数分配近似的内存空间。<br>
group - 一组线程的集合，方便线程的统一管理；比如可以查看一共有多少个active状态的线程（返回的是一个估计值），同时interuppt所有线程等。

**private static synchronized int nextThreadNum()**<br>
从0开始，每次加1；默认情况下不指定线程名会就会以："Thread-" + nextThreadNum() 命名，指定线程名后则不会再调用这个方法；

**private static synchronized long nextThreadID()**<br>
生成threadId，最终赋值为 private long tid;这个属性。

**public static native Thread currentThread();**<br>
静态方法，获取当前线程

**public static native void yield();**<br>
静态方法，通知线程调度器，当前线程可以让出自己正在使用的CPU；不过调度器也许会忽略这一个通知。<br>
一般可以用于启发式尝试管理多线程之间的进度，让CPU超负载的线程可以多分得一些CPU；或者是在多线程测试，复现bug阶段可以尝试使用。实际上用的比较少。

**public static native void sleep(long millis)**<br>
程序暂停执行，但并不放弃锁







