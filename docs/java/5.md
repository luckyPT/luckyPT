内存结构与垃圾回收
====
大致分为四部分堆、栈、方法区、程序计数器<br>
栈和程序计数器每个线程独有的，不共享；堆和方法区是各个线程共享的。
### 堆
堆中存放的是java对象实例，在JDK8中，String常量池也存在于堆中。

进一步细分为新生代和老生代；新生代内存是连续的，所以分配很快，新生代又分为3部分，分别命名为Eden，from，to；具体区别在总结垃圾回收时详细说明；

### 栈
存储基本类型的变量和对象在JVM的地址；可以细分为虚拟机栈和本地方法栈；栈是由栈桢构成，可以把一个方法当作一个栈桢；方法的执行就是栈桢进栈和出栈的过程。

### 方法区
用于存储类信息（类全限定名，访问权限，超类，字段的权限类型名称等），静态变量，方法（名称，权限、输入输出、字节码、异常表），类加载器的引用（加载类时用到的类加载器），类实例（并不是指new的实例，而是通过Class.forName()获取的类实例）

### 程序计数器
也是虚拟机的一小块内存，可以看作是字节码行号指示器，会记录正在执行的java字节码的行号，通过改变这个行号来选取下一条要执行的指令；常见的分支、跳转、循环、异常等都需要依赖行号指示器实现。

### 内存设置
设置项|含义
--|--
-Xmx|堆的最大内存|
-Xms|堆的初始值(最好与-Xmx保持一致)|
-Xmn|年轻代大小
-XX:NewRatio|年轻代与老年代的比例（默认是1:2）
-XX:SurvivorRatio|设置eden与from的比值，默认为8即年轻代按8:1:1划分
-Xss|线程栈的大小，默认为1M
-XX:MaxPermSize|持久代大小


### 垃圾回收算法

#### 复制算法
大体思路是将内存分成1：1两部分，其中一个称为from；另一个称为to；从from的根对象开始进行深度遍历，遇见存活的对象就复制到to中，对于已经复制过的对象会被标记为copied，并在forwarding中记录新对象的地址以便于其余引用的修改。当复制完成后，就会清除from中的数据；

另外还有一种改进的复制算法（cheney复制算法），大体思路相同，只不过是采用广度优先搜索；首先复制根对象（如A和B），这时有两个指针，scan指向A，free指向内存的下一个存储位置（B后面的空闲内存）；之后对A进行搜索，搜索完毕时，scan指向B；free随着复制进行移动，一直指向下一个空闲位置；直到scan和free两个地址相等。详见：
https://blog.csdn.net/u014228375/article/details/68957510 这样做的好处是相比递归迭代（深度搜索），可以抑制调用函数的额外负担和栈的消耗，缺点是相关联的对象在内存上未必是相邻的；

复制算法适用于存活率较低的情况下，这样遍历耗时比较小。所以通常用于新生代的垃圾回收。<br>
缺点：浪费内存，总有一半的内存空间不能得到充分利用。<br>
优点：回收之后，没有内存碎片化的现象，并且相关联的对象物理上距离比较近，与缓存兼容性更好，有利于提高访问性能。只遍历一遍，并且只遍历活的对象，耗时相对较少。


#### 标记清除算法

#### 标记整理算法

### 垃圾回收器

#### Serial & Serial Old收集器

#### ParNew

#### Parallel Scavenge & Parallel Old

#### CMS

#### G1
